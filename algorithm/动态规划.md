# 动态规划

## 定义

动态规划（dynamic programming）是运筹学的一个分支，是求解决策过程（decision process）最优化的数学方法。

动态规划的核心就是记住已经解决过的子问题的解。

## 动态规划算法的两种形式

记住求解的方式有两种：1. **自顶向下的备忘录法**， 2. **自底向上**

斐波拉契数列（Fibonacci）

```text
Fibonacci(n) = 0; n = 0

Fibonacci(n) = 1; n = 1

Fibonacci(n) = Fibonacci(n - 1) + Fibonacci(n - 2)
```

递归版本

```java
public int Fibonacci(int n) {
    if (n <= 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    }
    
    return Fibonacci(n - 1) + Fibonacci(n - 2);
}
```

<img src = "E:\gitResource\StandyDoc\image\Fibonacci递归图.png"/>

上面的递归树中的每一个子节点都会执行一次，很多重复的节点被执行。由于调用每个函数的时候都要保留上下文，所以空间开销也不小。如果在执行的时候把执行过程中执行过的子节点保存起来，后面用到的时候直接调用，可以节约大量的时间。

**自顶向下的备忘录法**

```java
public static int Fibonacci(int n) {
    if (n <= 0) {
        return 0;
    }
    int[] Memo = new int[n + 1];
    Memo[0] = 0;
    for (int i = 1; i <= n; i++) {
        Memo[i] = -1;
    }
    return fib(n, Memo);
}
public static int fib(int n, int[] Memo) {
    if (Memo[n] != -1) {
        return Memo[n];
    }
    if (n <= 1) {
        Memo[n] = 1;
    }
    else {
        Memo[n] = fib(n - 1, Memo) + fib(n - 2, Memo);
    }
    return Memo[n];
}
```

创建一个 n + 1 大小的数组保存求出的斐波拉契数列中的每一个值，然后有需要就直接调用而不用重新计算。

**自底向上的动态规划**

```JAVA
public static int fib(int n) {
    if (n <= 0) {
        return n;
    }
    int[] Memo = new int[n + 1];
    Memo[0] = 0;
    Memo[1] = 1;
    for (int i = 2; i <= n; i++) {
        Memo[n] = Memo[n - 1] + Memo[n - 2];
    }
    return Memo[n];
}
```

## 动态规划解题步骤

1. 确定dp数组以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组